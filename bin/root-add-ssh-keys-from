#!/bin/bash

set -euo pipefail
IFS=

usage () {
    echo "$0 uid"
    echo "  Copies over the authorized ssh keys of user uid (which must be numerical?)"
    echo "  to the root user's authorized keys file."
    echo "  Safe to call multiple times in parallel in the sense"
    echo "  that it will not destroy the old entries, but one of the"
    echo "  concurrent invocation's changes will be lost."
    exit 1
}

if [ $# -ne 1 ]; then
    usage
fi

presudouid=$1


01ok () {
    set +e
    "$@"
    [ $? -eq 0 -o $? -eq 1 ]
}

passwd_field () {
    local passwd=$1
    local fieldindex=$2
    local - ; set +x
    set -eu
    local IFS
    IFS=:
    read -ra pw < <(printf '%s\n' "$passwd")
    printf '%q\n' "${pw[$fieldindex]}"
}

uid_passwd () {
    local uid=$1
    local - ; set +x
    set -eu
    getent passwd "$uid"
}

uid_name () { local uid=$1; local - ; set +x; set -eu; local passwd; passwd=$(uid_passwd "$uid"); passwd_field "$passwd" 0; }
uid_home () { local uid=$1; local - ; set +x; set -eu; local passwd; passwd=$(uid_passwd "$uid"); passwd_field "$passwd" 5; }

uid_authorizedkeysfile () {
    local uid=$1
    local - ; set +x
    set -eu
    local home
    home=$(uid_home "$uid")
    printf '%q\n' "$home/.ssh/authorized_keys"
}


from=$(uid_authorizedkeysfile "$presudouid")
to=$(uid_authorizedkeysfile 0)
if [ "$from" = "$to" ]; then
    echo "$0: odd, should not be identical, BUG?: '$from', '$to'"
    # Well, unless both users were really configured to have
    # the same dir, but that would be odd since
    # insecure/voiding sudo anyway.
    #do_nosudo_force # really?
    exit 1
else
    cleaned=$(mktemp)

    if [ -e "$to" ]; then
        # Remove entries from AWS
        01ok grep -v 'Please login as the user' < "$to" > "$cleaned"
        # keep backup, all of them due to concurrency, use file's inode
        # number for guaranteed conflict freedom
        ino=$(stat --printf '%i' "$to")
        ln "$to" "$to.$ino~" || true
    fi

    # Add entries from $from which are not in $cleaned
    tmp=$(mktemp)
    {
        cat "$from"
        echo
        cat "$cleaned"
        echo
    } > "$tmp"
    tmp2=$(mktemp)
    LANG=C sort -u < "$tmp" > "$tmp2"
    new=$(mktemp -p "$(dirname "$to")")
    egrep -v '^$' < "$tmp2" > "$new"
    chmod go-rwx "$new"
    mv -f "$new" "$to"
fi

